---
title: "CDR3 Differential Analysis"
author: "Sean Ryan"
date: "3/23/2020"
output: html_document
---
# Analysis of P and N Additions in Differentially Expressed CDR3-alpha Sequences in Virtual Memory and Naive CD8 T Cells

## Introduction
Recently in the Savage lab we have been investigating a population of CD8 T cells that have the characteristics of memory cells yet exist in unprimed mice, termed “Virtual Memory Cells” (VM). Using mice expressing a fixed transgenic TCR chain, we sequenced the complementarity determining region 3 (CDR3) of the TCR-alpha chains expressed by purified CD8-VM and CD8-Naive T cells from 5 mice. The CDR3 region is generated by V(D)J recombination, and spans a region of the TCR that interacts directly with the peptide in the peptide:MHC presented on target cells. During the process of V(D)J recombination, the enzymes RAG and TdT work to add nucleotides to the V-J junction in order to increase the junctional diversity of the TCR. Here, the nucleotides added by RAG are called “P nucleotides” and the nucleotides added by TdT are called “N nucleotides”. In a recent study, our lab has shown that VM cells express generally self-reactive TCRs (Miller et al, Nature Immunology, accepted). At the same time, it has been hypothesized that TCRs which have lower amounts of P and N added nucleotides between their V and J domains (and are thus closer to germline) also tend to be more self-reactive. In this analysis, I will calculate the number of P and N additions in each of the recurring, differentially expressed CDR3-alpha sequences generated for both the VM and Naive data sets and compare the CDR3 sequences that are found in each compartment to see if VM CDR3 sequences have fewer junctional P and N additions on average than the Naive CDR3 sequences. 

## Loading, Compiling, and Pre-Processing the Data
First we need to load our packages and CSV files:
```{r, warning=FALSE}
rm(list = ls())
library(tidyverse)

Vm_data_1 <- read.csv("VM1.csv")
Vm_data_2 <- read.csv("VM2.csv")
Vm_data_3 <- read.csv("VM3.csv")
Vm_data_4 <- read.csv("VM4.csv")
Vm_data_5 <- read.csv("VM5.csv")

N_data_1 <- read.csv("N1.csv")
N_data_2 <- read.csv("N2.csv")
N_data_3 <- read.csv("N3.csv")
N_data_4 <- read.csv("N4.csv")
N_data_5 <- read.csv("N5.csv")

diff_data <- read.csv("DiffAnalysis_Comb.csv")
```
The last csv in the list, uploaded to the variable "diff_data", contains the list of all differentially expressed TCRs from both the naive (2405 TCRs) and VM (493 TCRs) compartments. These are the CDR3 sequences identified to be differentially expressed and have an FDR of less than 0.05 as shown in  figure 1a of Christine's Nature Immunology paper.

We still need the raw data in order to find the P and N additions for the CDR3 sequences on the "diff_data" list. In order to use this data we need to compile all of the raw data from the individual mice into separate files for the VM and the Naive:
```{r, warning=FALSE}
VM_data <- merge(Vm_data_1, Vm_data_2, all = TRUE)
VM_data <- merge(VM_data, Vm_data_3, all = TRUE)
VM_data <- merge(VM_data, Vm_data_4, all = TRUE)
VM_data <- merge(VM_data, Vm_data_5, all = TRUE)

N_data <- merge(N_data_1, N_data_2, all = TRUE)
N_data <- merge(N_data, N_data_3, all = TRUE)
N_data <- merge(N_data, N_data_4, all = TRUE)
N_data <- merge(N_data, N_data_5, all = TRUE)
```

N and P additions occur between V region and J region of a TCR. These data have the basepair location of the V region end and the J region start, by subtracting these two values we can get the total number of addtions. Generally, the J region will start on the next base after the V region ends. This means we need to subtract 1 from the difference in order to get the real number of insertions. Sometimes, the V and J region overlap and start/end on the same base, for this case we will generate -1 as our number of additions, we will need to change all -1 values to 0.
Here we will calculate the number of P and N additions for every CDR3 sequence in the raw data set as a new column named "PN_Addn". 
We will also rename the copy column to "read_count" as copy is a function name in R:
```{r, warning=FALSE}
VM_data<- VM_data %>% mutate(PN_Addn = JReadBegin - VReadEnd - 1)
VM_data<- VM_data %>% mutate(PN_Addn = replace(PN_Addn, PN_Addn == -1, 0))

N_data <- N_data %>% mutate(PN_Addn = JReadBegin - VReadEnd - 1)
N_data <- N_data %>% mutate(PN_Addn = replace(PN_Addn, PN_Addn == -1, 0))
#rename copy
VM_data <- VM_data %>% rename(read_count = copy)
N_data <- N_data %>% rename(read_count = copy)
```

In order to use the dfferentially expressed data as a key to find these TCRs in the original data set we need to separate out the VM and Naive CDR3 sequences from the joined list. The VM CDRs have a logFC > 0  while the N CDRs have a logFC < 0:
```{r, warning=FALSE}
diff_data <- diff_data %>% rename(CDR = ï..CDR)
VM_diff_data <- diff_data %>% filter(logFC > 0)

N_diff_data <- diff_data %>% filter(logFC < 0)
```
This gives two new data frames with only VM or N CDR sequences

## Processing the Data for the Unweighted Individual CDR3 Analysis
In order to get only one copy of each CDR3 sequence from the list provided by the differential data we need to remove the bad reads and duplicated TCRs from the raw data prior to preforming the search:
```{r, warning=FALSE}
Bad_Vm_reads <- subset(VM_data, CDR3.pep. %in% "*")
VM_data_clean <- anti_join(VM_data, Bad_Vm_reads)

VM_data_clean <- VM_data_clean %>% arrange(desc(read_count)) 
VM_data_clean <- subset(VM_data_clean, !duplicated(CDR3.pep.))

Bad_N_reads <- subset(N_data, CDR3.pep. %in% "*")
N_data_clean <- anti_join(N_data, Bad_N_reads)

N_data_clean <- N_data_clean %>% arrange(desc(read_count))
N_data_clean <- subset(N_data_clean, !duplicated(CDR3.pep.))
```

Now we can use the differentially expressed VM and N CDR3 lists as keys to search and retreive these TCRs from the raw data that contains thier P and N addition numbers:
```{r, warning=FALSE}
VM_data_clean <- VM_data_clean %>% rename(CDR = CDR3.pep.)
VM_diff_info <- inner_join(VM_data_clean, VM_diff_data, by = "CDR")

N_data_clean <- N_data_clean %>% rename(CDR = CDR3.pep.)
N_diff_info <- inner_join(N_data_clean, N_diff_data, by = "CDR")
```
This action results in two lists for VM and N data that contain the correct number (493 and 2405, respectively) of CDR3s and thier corresponding number of P and N additions.

In order to plot these data we will need to calculate the total number and percentage of CDR3s that have each number of P and N additions:
```{r, warning=FALSE}
VM_Perc_indiv <- VM_diff_info %>% 
                  group_by(PN_Addn) %>% 
                  tally() %>% 
                  mutate(Percent_in_Repitore = (n/sum(n))*100)

N_Perc_indiv <- N_diff_info %>% 
                group_by(PN_Addn) %>% 
                tally() %>% 
                mutate(Percent_in_Repitore = (n/sum(n))*100)
```

## Processing the Data for the Read-Count-Weighted Analysis of each CDR3 Sequence
To calculate the total number of reads each CDR3 sequence recieved during the sequencing process we will not exclude duplicates and instead pull out the differentially expressed CDRs directly from the raw data:
```{r, warning=FALSE}
VM_data <- VM_data %>% rename(CDR = CDR3.pep.)
VM_data_info_FC <- inner_join(VM_data, VM_diff_data, by = "CDR")
test_VM <- subset(VM_data_info_FC, !duplicated(CDR))

N_data <- N_data %>% rename(CDR = CDR3.pep.)
N_data_info_FC <- inner_join(N_data, N_diff_data, by = "CDR")
test_N <- subset(N_data_info_FC, !duplicated(CDR))
```
Here test_VM and test_N are used to make sure we are still getting the proper number of non-duplicated TCRs, because test_VM is a list of 493 CDRs and test_N is a list of 2405 CDRs we know that our variables that do allow duplicates have all of the proper CDR sequences included.

In order to plot these data we will need to calculate the total number and percentage of CDR3s that have each number of P and N additions:
```{r, warning=FALSE}
VM_Perc_Norm <-  VM_data_info_FC%>% 
                  group_by(PN_Addn) %>% 
                  tally(wt = read_count) %>% 
                  mutate(Percent_in_Repitore = (n/sum(n))*100)

N_Perc_Norm <-  N_data_info_FC %>% 
                group_by(PN_Addn) %>% 
                tally(wt = read_count) %>% 
                mutate(Percent_in_Repitore = (n/sum(n))*100)
```

## Plotting the Unweighted and Weighted Data Sets
First the unweighted data sets(VM, N, and an overlay of the two):
```{r, warning=FALSE}
pl_VM1 <- VM_Perc_indiv %>% ggplot() + 
          aes(x = as.factor(PN_Addn), y = Percent_in_Repitore) +
          geom_histogram(stat = "identity", fill = "blue") +
          labs(y= "Percentage of TCRs", x = "Number of P and N Additions") +
          ggtitle("Virtual Memory Repitore P and N Addition Frequency")
pl_VM1

pl_N1 <- N_Perc_indiv %>% ggplot() + 
        aes(x = as.factor(PN_Addn), y = Percent_in_Repitore) +
        geom_histogram(stat = "identity", fill = "red") +
        labs(y= "Percentage of TCRs", x = "Number of P and N Additions") +
        ggtitle("Naive Repitore P and N Addition Frequency")
pl_N1

Pl_comb <- ggplot() + 
            geom_histogram(data = VM_Perc_indiv, stat = "identity", show.legend = TRUE,
                 aes(x = PN_Addn, y = Percent_in_Repitore, group = 1), color='blue', fill = "blue", alpha = 0.4) + 
            geom_histogram(data = N_Perc_indiv, stat = "identity", show.legend = TRUE,
                 aes(x = PN_Addn, y = Percent_in_Repitore, group = 1), color='red', fill = "red", alpha = 0.4) +
            scale_x_continuous(limits = c(-2, 16)) +
            labs(y= "Percentage of TCRs", x = "Number of P and N Additions") +
            ggtitle("Virtual Memory Repitore (Blue) vs Naive Repitore (Red) P and N Addition Frequency")
Pl_comb
```

And the weighted data sets (VM, N, and an overlay of the two):
```{r, warning=FALSE}

pl_VM_norm <- VM_Perc_Norm %>% ggplot() + 
              aes(x = as.factor(PN_Addn), y = Percent_in_Repitore) +
              geom_histogram(stat = "identity", fill = "blue") +
              labs(y= "Percentage of Total TCR Reads", x = "Number of P and N Additions") +
              ggtitle("Virtual Memory Repitore P and N Addition Frequency per CDR3 Read Count") 
pl_VM_norm

pl_N_norm <- N_Perc_Norm %>% ggplot() + 
              aes(x = as.factor(PN_Addn), y = Percent_in_Repitore) +
              geom_histogram(stat = "identity", fill = "red") +
              labs(y= "Percentage of Total TCR Reads", x = "Number of P and N Additions") +
              ggtitle("Naive Repitore P and N Addition Frequency per CDR3 Read Count")
pl_N_norm

Pl_comb_norm <- ggplot() + 
                geom_histogram(data = VM_Perc_Norm, stat = "identity", show.legend = TRUE,
                 aes(x = PN_Addn, y = Percent_in_Repitore, group = 1), color='blue', fill = "blue", alpha = 0.4) + 
                geom_histogram(data = N_Perc_Norm, stat = "identity", show.legend = TRUE,
                 aes(x = PN_Addn, y = Percent_in_Repitore, group = 1), color='red', fill = "red", alpha = 0.4) +
                scale_x_continuous(limits = c(-2, 16)) +
                labs(y= "Percentage of Total TCR Reads", x = "Number of P and N Additions") +
                ggtitle("Virtual Memory Repitore (Blue) vs Naive Repitore (Red) P and N Addition Frequency per CDR3 Read Count")
Pl_comb_norm
```

## Statistical Tests
TO test for statistical significance in any changes in distribution, the paired Wilcoxon signed-rank test (two-tailed), which tests for distribution shift, 
and the Kolmolgorov-Smirnov (KS) test, which tests for differences in distribution shape will be preformed for both the unweighted and weighted data sets. Both of these tests have available plug ins in R.

Since the Wilcoxon test is a paired test it requires the data used to be in two vector lists of the same length, meaning we need to fill in any missing rows in either data set to with zeros in order for the data sets to be compared for each number of N additions in a pair-wise fashion. For example, the unweighted Naive data has no P and N additions of length 13, but the unweighted VM data does, so this row needs to be created and fileld with zeros in order for pair-wise testing to occur. The new rows are added at the end of the set, so the arrange function is used to keep the data in decending order of P and N additions.
```{r, warning=FALSE}
N_indiv_stat <- N_Perc_indiv %>% 
                add_row(PN_Addn = 13, n = 0, Percent_in_Repitore = 0) %>% 
                arrange(PN_Addn)
VM_indiv_stat <- VM_Perc_indiv %>% 
                  add_row(PN_Addn = 12, n = 0, Percent_in_Repitore = 0) %>% 
                  add_row(PN_Addn = 14, n = 0, Percent_in_Repitore = 0) %>% 
                  arrange(PN_Addn)
VM_Norm_stat <- N_Perc_indiv %>% 
                add_row(PN_Addn = 15, n = 0, Percent_in_Repitore = 0) %>% 
                add_row(PN_Addn = 13, n = 0, Percent_in_Repitore = 0) %>% 
                arrange(PN_Addn)
```

Now we can preform the Wilcoxon test.
First, the unweighted data:
```{r, warning=FALSE}
wilcox.test(VM_indiv_stat$Percent_in_Repitore, N_indiv_stat$Percent_in_Repitore, paired=TRUE, alternative = "less")
```
and then the weighted data:
```{r, warning=FALSE}
wilcox.test(VM_Norm_stat$Percent_in_Repitore, N_Perc_Norm$Percent_in_Repitore, paired=TRUE, alternative = "less")
```
Neither indicates a statistically significant shift in the distribution (P>0.05).

Now for the KS tests.
First, the unweighted data:
```{r, warning=FALSE}
ks.test(VM_indiv_stat$Percent_in_Repitore, N_indiv_stat$Percent_in_Repitore, alternative = "less")
```
and then the weighted data:
```{r, warning=FALSE}
ks.test(VM_Norm_stat$Percent_in_Repitore, N_Perc_Norm$Percent_in_Repitore, alternative = "less")
```
Again, neither indicates a statistically significant change in the shape of the distribution (P>0.05).

## Conclusion
While it appears that the VM compartment tends to have a slightly higher magnitude of TCRs with 0 P and N additions relative to the naive compartment, none of these differences are statistically significant. Therefore, these findings indicate that there is no immediate correlation between the auto-reactivity of these recurring differentially expressed VM CDR3 regions and a lower number of P and N additions as compared to thier naive CDR3 region counterparts. 

